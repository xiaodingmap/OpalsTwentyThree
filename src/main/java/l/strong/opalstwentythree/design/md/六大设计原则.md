# 设计原则
## 单一职责原则
要求一个接口or类只有一个原因引起变化。**单一职原则提出一个编写程序标准：用“职责”or“变化原因”来衡量接口或类设计的是否优良**
- 类复杂性降低
- 可维护性增强
- 可读性提高
- 变更引起风险降低

接口要求单一，但实现类需要多方面考量，过度的单一职责会带来类的剧增，造成系统复杂不易维护，具体还要在项目中把握度。

单一职责不仅适用于接口、类，也适用于方法，即一个方法尽量只做一件事，方法职责一定要清晰。在实际使用中，我们往往更容易做到接口和方法的单一职责，
对于类，受到现实因素制约，很难做到，故不做要求。（比如甲方只有一个接口给你，所有事情都在这个接口里，你还会考虑类的单一职责原则吗？）

个人意见：**接口和方法一定要做到单一职责，类只能说尽量**
## 里氏替换原则
何为里氏替换原则？

- 所有**引用基类**的地方必须能透明的使用**子类**的对象
- 在类中调用其他类时必须使用父类or接口，否则说明设计已经违背了LSP原则
- 如果子类不能完整实现父类的方法，或者父类的某些方法在子类中已经发生“畸变”（比如玩具枪继承枪的属性，可以去被用在真正的士兵手里射击），则建议
断开父子继承关系，采用依赖、聚集、组合等关系代替继承。
- 子类中方法的前置条件必须与超类中被覆写的方法的前置条件相同或者更宽松，只有这样才能保证子类在没有覆写的情况下，不会悄无声息的越过父类调到同名子类重载方法，从而引发代码
逻辑混乱。
- 覆写或者实现父类的方法的方法是，输出结果可以被缩小

继承（Java采用单一继承，C++采用多重继承，一个子类可以继承多个父类）

优点：
- 代码共享，子类拥有父类的方法和属性
- 提高代码复用性
- 子类形似父类又异于父类
- 提高代码可拓展性，因为子类实现了父类的方法（开源框架很多扩展接口都是通过继承来实现）
- 提高开放性

缺点：
- 侵入性，子类必须拥有父类的属性和方法
- 降低代码灵活性
- 增强耦合性，父类常量、变量、方法被修改时，要考虑子类修改，在缺乏规范环境时，可能有很糟糕后果——大段代码需要重构

覆写(Override)：方法名相同，入参相同

重载(Overload)：方法名相同，入参不同


## 依赖倒置原则
原始定义：
- 高层模块不应该依赖于底层模块，两者都应该依赖其抽象；
- 抽象不应该依赖细节；
- 细节应该依赖抽象

对应在Java语言中的表现就是：
- 模块间依赖通过抽象发生，实现类之间不发生直接依赖关系，其依赖关系是通过接口or抽象类产生的
- 接口or抽象类不应该依赖于实现类；
- 实现类应该依赖接口or抽象类

即**面向接口编程**

优点：
 - 减少类之间的耦合性，提高系统稳定性
 - 降低并行开发引起的风险，提高代码的可读性和可维护性


