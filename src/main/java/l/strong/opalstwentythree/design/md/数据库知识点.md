# MYSQL索引
## 索引排序
- 最左匹配列

假如有联合索引name_birth_phoneNumber，那么只有name匹配到才会匹配birth一直递加，因为B+树的数据页和记录先是按照name列值排序，name相同时才使用birthday列排序，而无法直接按照birthday列排序
- 如果对多个列同时进行范围查找的话，只对索引最左边列进行范围查找时才能用到B+树索引

 比如有联合索引 name_birthday_phoneNumber 

语句：SELECT * FROM person_info WHERE name > 'Asa' AND name > 'Barlow' AND birthday > '1980-01-01';
上述对于联合索引来说，只有name能命中，联合索引的意义是只有name相同的值才会按照birthday排序，只有birthday相同的值
才会按照phoneNumber排序，此sql中name是范围查找而非等于，故birth是无排序的

如果是SELECT * FROM person_info WHERE name = 'Asa' AND  birthday > '1980-01-01' AND brithday < '1996-10-14' AND phoneNumber  = '12323232132';
则能命中name和birthday
- 用于文件排序

查询语句完成之后经常需要order By排序，一般是把记录加载到内存中，再使用快排等排序算法在内存中排序返回客户端，如果查询结果集太大而内存不能排序时，需要磁盘空间来存放中间结果，比较慢，所以索引
可以用于文件排序（在内存或者磁盘上进行排序的方式统称为文件排序）

- 联合索引排序注意事项

ORDER BY的子句后边的列的顺序也必须按照索引列的顺序给出，颠倒顺序不能使用索引

对于联合索引排序的场景，要求各个排序列的顺序是一致的，都是ASC或都为DESC，ORDER BY子句后的列如果不加ASC或者DESC默认按照ASC排序

- WHERE语句排序使用索引注意事项
如果where语句出现了非排序使用到的索引列，则排序用不到索引

SELECT * FROM person_info WHERE country = 'China' ORDER BY name LIMIT 10;
该查询只能把符合搜索条件country = 'China'的记录提取出来后再排序，使用不到索引；与以下索引区分：
SELECT * FROM person_info WHERE name = 'A' ORDER BY birthday,phone_number LIMIT 10;
虽然此查询也有搜索条件，但是name = 'A' 可以用到联合索引name_birthday_phone_number,而且过滤剩下的记录还是按照birthday,phone_number排序，所以还是可以
使用索引排序，因为该联合索引中本来就是 匹配name之后按照birth和phone排序，和此查询语句的顺序一致。
## 回表代价

因为使用索引，查找数据，需要先去索引的B+树，找到索引对应的主键，再去聚簇索引，查到整表数据，所以就涉及到回表的操作，而直接使用聚簇索引就是全表扫。
在很多时候，二级索引+聚簇索引这种回表的方式，并不一定优于全表扫。

二级索引：按照索引建立的B+树,在磁盘中存储相连，故称访问二级索引为顺序I/O
聚簇索引：二级索引获取到的ID主键，可能并不相连，聚簇索引中记录是根据id顺序排列的，所以根据二级索引中找到的并不连贯的id在聚簇索引中找到完整用户记录可能
分布在不同的数据页中，这种读取方式我们称为随机I/O。一般情况，顺序I/O性能高于随机I/O

当需要回表的剧记录越多时，使用二级索引的性能就越低，查询优化器可能会选择直接全表扫，一般情况下，查询获取较少记录数会有优先让优化器倾向使用二级索引+回表，因为回表记录越少，性能提升越高。
比如：
SELECT * FROM person_info WHERE name > 'Asa' AND name < 'Barlow' LIMIT 10;

添加LIMIT 10的查询更容易让优化器采用 二级索引+回表的方式查询

## 覆盖索引
为彻底告别回表操作带来的性能损耗，建议：最好在查询列表里只包含索引列。这样查完二级索引就能拿到需要的数据，无需回表进一步查询，这种只需要用到索引的查询方式
成为 索引覆盖。

如果业务需要查询索引以外的列，还是保证以业务需求为重，但是**很不鼓励用* 作为查询列表**，最好把需要查询的列依次标明。


## 如何挑选索引
- 只为出现在WHERE子句中的列、连接子句中的连接列、或者出现在ORDER BY OR GROUP BY 子句中的列创建索引。
- 考虑列的基数，即某一列中不重复数据的个数。在记录行数一定的情况下，列基数越大，列值越分散，反之越集中。最好为那些列基数大的列建立索引，为基数太小的列建立索引，可能更容易导致
回表查询，因为你还会去考虑他不重复的部分，所以效果可能不好。
- 索引列的类型尽量小，类型大小指该类型表示的数据范围的大小。比如能用INT就不要使用BIGINT
- 索引字符串值的前缀，只对字符串的前几个字符进行索引 比如 KEY idx_name_birthday(name(10),birthday),但是这种无法对前十个字符相同，后面字符不同的记录排序，使用索引列前缀的方式
无法支持用索引排序，只好用文件排序。
- 让索引列在比较表达式中单独出现

假设表有一个整数列my_col,建了索引，如下两个where子句：
1 WHERE my_col * 2 < 4    2 WHERE my_col < 4/2
第一个WHERE子句中my_col列并不是以单独列形式出现的，存储引擎会遍历所有记录，计算表达式是不是小于4，这种使用不到索引

**如果索引列在比较表达式中不是以单独列的形式出现，而是以某个表达式，或者函数调用形式出现的话，是用不到索引的
